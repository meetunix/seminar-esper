\documentclass{acm_proc_article-sp}
\usepackage{minted}
\usepackage{hyperref}
\usepackage{ngerman}
\usepackage{graphics}
\usepackage{float}
\usepackage{colortbl}
\usepackage{amsmath}
\usepackage{breakurl}
\hypersetup{
    pdftitle={Complex Event Processing am Beispiel von Esper },
    pdfauthor={Martin Steinbach},
    pdfkeywords={Seminar, Rostock, WiSe 2018, 2018},
    pdfsubject={Seminar Event Driven Programming},
    pdfcreator={Martin Steinbach},
    citecolor=blue,
    hypertexnames=false,
    %linktocpage,
    pdfpagelabels,
    plainpages=false,
    backref,
    urlcolor=blue,
    menucolor=red,
    linkcolor=black,
    colorlinks=true,
    bookmarksnumbered,
    %pdffitwindow
}
%\hyphenation{
 
%}

\usemintedstyle{}


\definecolor{shadecolor}{gray}{.92}
\begin{document}


\title{Complex Event Processing am Beispiel von Esper}
\numberofauthors{1} 
\author{
\alignauthor
Martin Steinbach\vspace{0.1cm}\\
       \affaddr{Institut für Informatik}\\
       \affaddr{Universität Rostock}\\
       %\affaddr{Rostock, Deustchland}\\
       \email{\footnotesize martin.steinbach@uni-rostock.de}}




\maketitle

\begin{abstract}
    \vspace{0.1cm}
\begin{itemize}
    \item steige steigerung der Datenmengen -> keine speicherung möglich
    \item kostengünstige Sensortechnik 
\end{itemize}
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
\end{abstract}

%\terms{Theory}

\keywords{EDA, CEP, Esper} % NOT required for Proceedings

\section{Einleitung}
\vspace{0.1cm}
Jede Aktion in der IT-gestützten Welt erzeugt 
Informationen in Form von Daten. Dabei spielt es keine Rolle ob ein Verweis in einem 
sozialen Netzwerk verwendet wird, ob ein Sensor einen Messwert meldet, oder jemand eine 
Aktie kauft. Betrachtet man diese Daten, scheint der Informationsgehalt gering und die 
Datenmenge überschaubar. Aus diesen Grund lässt sich aus diesen Einzelinformationen kaum 
eine nutzbringende Auskunft für ein Gesamtsystem konstruieren. In der Praxis relevante
Fragestellungen wären zum Beispiel: Wie oft wird ein Verweis innerhalb einer Zeitspanne 
ausgelöst und zu welcher Tageszeit hauptsächlich? Wie viele Messwerte eines Sensors 
werden benötigt um konkrete Aussagen zu einem Messobjekt machen zu können? Wann und 
welche Menge an Aktien eines Unternehmens werden über einen Zeitraum erworben, 
beziehungsweise verkauft?\\
Um diese exemplarischen Fragen zu beantworten steigt die Anzahl der benötigten Daten sehr 
schnell an und eine Verarbeitung mit anschließender Analyse der Daten bedarf wesentlich 
mehr Aufwand und Zeit. Möchte man zudem nicht nur historische Daten analysieren, sondern 
möglichst ohne Zeitverzögerung eine Antwort auf aktuell erhobene Daten erhalten, dann 
bietet sich die Technologie \textit{Complex Event Processing (CEP)} an. Mithilfe der von 
\textit{CEP} angebotenen Verfahren lassen sich riesige und aktuellste Datenmengen nahezu 
direkt verarbeiten. Im Gegensatz zu Datenbankmanagementsystemen, in denen man auf einer 
endlichen Menge an Daten operiert, existieren auch für \textit{CEP} fertige 
Softwarelösungen zur systematischen Analyse von massiven Datenströmen. Eine dieser 
sogenannten \textit{CEP-Engines} ist Esper, laut \cite{fraunhofer} besitzt Esper eine 
sehr große Verbreitung, wird im kommerziellen Umfeld von Namhaften Unternehmen 
verwendet und weist keinen Fokus auf eine spezielle Art der Verwendung auf. Esper ist 
freie Software\footnote{General Public License v2} und steht damit jedermann für jeden 
Zweck zur Verfügung.\\
Neben der Funktionalität die Esper bereit stellt, einer Erklärung der Esper-eigenen 
Abfragesprache \textit{EPL} und einer Beispielanalyse, werden zuvor die Grundlagen 
von \textit{Complex Event Processing} erläutert. Darunter fällt die Klärung essentieller 
Begriffe, eine Einordnung von \text{CEP} und die Erklärung von Abfragesystematiken.

%
% Hauptteil
%

\section{CEP am Beispiel von Esper}
\vspace{0.1cm}
\textbf{TBD: Inhaltangabe}
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\
lorem ipsum lorem ipsum loren ipsum lorem ipsum lorem \\

\subsection{Einordnung von CEP}
\vspace{0.1cm}
\textit{CEP} kann als Bestandteil von \textit{Event-Driven Architecture (EDA)} verstanden 
werden. \textit{EDA} unterscheidet sich als Architekturstil 
grundlegend von anderen Stilen, so findet in \textit{EDA} keine schrittweise Abarbeitung 
von vorher definierten Anweisungen statt um Daten zu verarbeiten. Wie in \cite{glossary} 
beschrieben, existieren stattdessen ereignisgesteuerte Komponenten, deren Interaktion 
untereinander ebenfalls über Ereignisse erfolgt. Damit ist der Begriff des Ereignisses 
ein elementarer und wird in Abschnitt \ref{begriffsbestimmung} ausführlich behandelt. 
\textit{CEP} kann wiederum als Komponente in einem \textit{EDA}-System zum Einsatz 
kommen, wie in Abbildung \ref{img:eda-struktur} aus \cite{bruns}.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/eda-struktur-bruns.jpg}
    \caption{\textit{EDA}-Struktur}
    \label{img:eda-struktur}
\end{figure}

\textit{CEP} ist in erste Linie als Sammelbezeichnung für verschiedene Paradigmen und 
Techniken für die Analyse und Verarbeitung von Ereignissen zu verstehen. Ziel ist es 
Wissen aus einer kontinuierlich nachströmenden Menge an Daten in Form von Ereignissen zu 
generieren. Dies geschieht zum Beispiel durch Korrelation oder Gruppierung von 
Ereignissen nach vorher definierten Regeln. Dabei kann eine Vielzahl von 
Ereignisquellen (Abbildung \ref{img:eda-struktur}) existieren, welche fortlaufend neue 
Ereignisse generieren. Trifft eine Regel auf eine Menge an Ereignissen zu, so wird daraus 
ein komplexes Ereignis (\cite{glossary}) generiert, welches abermals als atomares 
Ereignis für eine weitere 
\textit{CEP}-Instanz dienen kann. Ein komplexes Ereignis wird auch verwendet
um verschiedenartige Meldungen zu generieren, Prozesse zu initiieren oder um als 
Grundlage 
für Visualisierungen zu dienen. In \cite{bruns} wird ein Grundzyklus für 
ereignisgesteuerte Systeme identifiziert (Abbildung \ref{img:cep-zyklus}), der aus den 
drei Schritten Erkennen, Reagieren und Verarbeiten besteht.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/cep-zyklus-bruns.jpg}
    \caption{\textit{CEP}-Zyklus}
    \label{img:cep-zyklus}
\end{figure}

Den Beginn stellt dabei das \emph{Erkennen} dar, relevante Informationen (zum Beispiel 
Messwerte) werden ohne Verzögerung als Ereignisse interpretiert. Während der 
\emph{Verarbeitung} wird die Mustererkennung auf einen oder mehreren Ereignisströmen 
durchgeführt. Sobald Muster erkannt werden, \emph{Reagiert} man mit Meldungen oder mit 
der Generierung komplexer Ereignisse.\\
Laut \cite{eckert} gibt es zwei grundlegende Arten um 
komplexe Ereignisse zu identifizieren. Entweder über bereits bekannte Muster, die durch 
Regeln in Ereignisanfragesprachen formuliert werden können, oder über unbekannte Muster. 
Letztere benötigt allerdings Technologien wie \textit{MachineLearning} und 
\textit{DataMining}, daher wird in diesem Papier nicht darauf eingegangen.

\subsubsection{Begriffsbestimmungen}\label{begriffsbestimmung}
\vspace{0.1cm}
\textbf{\textit{Datenströme/Ereignisströme}}
sind kontinuierliche, kleinteilige Datensätze in der 
zeitlichen Reihenfolge ihres Auftretens oder ihrer Messung. Die Daten weisen eine geringe 
Komplexität auf und beziehen sich nur auf ein Datum (zum Beispiel den Messwert eines 
Sensors oder den Kurs eines Wertpapiers.). Die Ströme sind sind endlos und meist 
hochfrequent und massiv, daher können die Daten nicht persistent gespeichert werden.\\
Jeder Datensatz in einem Datenstrom bildet ein eigenes 
\textbf{\textit{Ereignisse}}. Im 
Allgemeinen kann laut \cite{glossary} ein Ereignis alles sein was eintreten kann, wie zum 
Beispiel ein Erdbeben, eine Finanztransaktion, das Betätigen einer Taste oder die 
Oktoberrevolution. Im speziellen ist ein Ereignis ein aufbereiteter Datensatz, welcher 
die Informationen eines Ereignisses beinhaltet und für die rechnergestützte Verarbeitung 
angepasst ist. Dazu ist es notwendig, dass zum Informationsgehalt des Ereignisses (den 
Kontextinformationen) auch eindeutige und strukturierte Metadaten erfasst werden. 
Exemplarisch 
kann ein Ereignis folgendermaßen aufgebaut sein (\cite{hedtstuck}):

\begin{table}[ht]
    \caption{Ereignisaufbau}
    \label{table:ereignis}\vspace{0.2cm}
    \centering{
        \renewcommand{\arraystretch}{1.3}
        \begin{tabular}{|l|c|}
            \hline
            \multicolumn{2}{|l|}{\cellcolor{shadecolor}\textbf{Metadaten}}\\
            \hline
            Ereignistyp\hspace{0.5cm} &   \texttt{Kursänderung}\\ 
            \hline
            Ereignisquelle\hspace{0.5cm} &   \texttt{Frankfurt}\\ 
            \hline 
            Zeitstempel &   \texttt{2018-11-21 22:14:00}\\
            \hline
            ID          &   \texttt{98127634}\\  
            \hline
            \multicolumn{2}{|l|}{\cellcolor{shadecolor}\textbf{Kontextinformation}}\\     
            \hline
            \multicolumn{2}{|l|}{\texttt{Name: acme GmbH}}\\
            \multicolumn{2}{|l|}{\texttt{Einkaufkurs: 32.5}}\\
            \multicolumn{2}{|l|}{\texttt{Letzer Kurs: 40.8}}\\
            \multicolumn{2}{|l|}{\texttt{Differenzbetrag: 5.7}}\\
            \multicolumn{2}{|l|}{\texttt{Aktualler Kurs: 42.1}}\\
            \hline
        \end{tabular} 
    }
\end{table}
Wobei die Felder \textit{Ereignistyp} und \textit{Ereignisquelle} nach \cite{bruns} 
optional sind. Wie man an den Metainformationen erkennen kann, stehen alle Ereignisse in 
impliziter Beziehung zueinander.\\
Im Verarbeitungsschritt (Abbildung \ref{img:cep-zyklus}) werden Beziehungen zwischen 
Ereignissen gesucht, diese werden durch \textbf{\textit{Ereignismuster}} beschrieben. Die 
Mustererkennung wird nur über einem bestimmtes Zeitintervall des Ereignisstromes 
ausgeführt und durch Ereignisanfragesprachen definiert. In \cite{bruns} werden drei Arten 
von Ereignismustern unterschieden. Können Muster ausschließlich durch boolesche 
Operatoren der Aussagelogik festgelegt werden, so fallen sie in die Kategorie der 
\textit{einfachen Ereignismuster}. Werden hingegen speziellere Operatoren nötig, um zum 
Beispiel die Reihenfolge oder Zeitfenster in den Ereignisse auftreten auszudrücken, 
gehören sie zur Kategorie der \textit{komplexen Ereignismuster}. Zur Kategorie der 
\textit{Abstrakten Ereignismuster} gehören die Muster, welche aus einem bereits erkannten 
Muster komplexe Ereignisse erzeugt um diese auf einer höheren Abstraktionsebene wieder 
zur Verfügung zu stellen.\\
Ein \textbf{\textit{Komplexes Ereignis}} ist eine Menge von Ereignissen, die durch ein 
Ereignismuster beschrieben sind.\\\label{begriff-ereignisregel}
\textbf{\textit{Ereignisregeln}} sind die syntaktische Abstraktion von Ereignismustern 
und werden mithilfe einer \textbf{\textit{Anfragesprache}} erstellt, laut \cite{bruns} 
existieren für diese 
Sprachen kein einheitlicher Standard. Daher existiert eine Fülle an Sprachen, die aber 
alle einige Eigenschaften Teilen. So bestehen alle in einer Anfragesprache formulierten 
Regeln aus einer Prämisse und einem Aktionsteil, wenn das Muster, Beziehungsweise die 
Bedingung in der Prämisse erfüllt ist, wird der Aktionsteil ausgeführt. Anfragesprachen 
sind grundsätzlich deklarativ, man beschreibt also ein Modell und muss keine Verfahren 
zur Mustererkennung implementieren. In \cite{eckert} werden auch reaktive Regeln erwähnt, 
diese Regeln definieren, wie auf komplexe Ereignisse reagiert werden soll.

\subsubsection{Beispielanwendungen}
\vspace{0.1cm}

\textbf{TBD!} wo wird und kann CEP eingesetzt werden\\


%
% Anfragesprachen
%
\subsection{Anfragesprachen}
\vspace{0.1cm}
Mithilfe von Ereignisanfragesprachen lassen sich Daten aus einer Ereignisfolge, eine 
endliche Menge an Ereignissen innerhalb des endlosen Ereignisstromes, extrahieren, 
verdichten, zeitliche zusammenhänge herstellen und Aktionen festlegen.

\subsubsection{Definition von Ereignisregeln}\label{kap:ereignisregeln}
\vspace{0.1cm}
In diesem Abschnitt wird eine Übersicht über die zur Verfügung stehenden Mengenalgebren 
in Anfragesprachen gegeben, dabei wird sich auf das Vorgehen in \cite{bruns} berufen.\\
Seien $A,B,C$ Ereignistypen und $a,b,c$ zugehörige Ereignisinstanzen, wobei gilt 
$a \in A$, $b \in B$ und $c \in C$. Eine Ereignisfolge wird durch $a_1a_2a_3b_1c_1b_21_4$
beschrieben.\\
Jede Ereignisalgebra enthält spezielle Operatoren, die auf Ereignisfolgen angewendet 
werden können und dabei z.B. zeitliche, kausale oder fachliche Zusammenhänge zwischen 
Ereignissen beschreiben. In \textbf{\textit{ereignistypbasierten Mustern}} legt der 
Sequenzoperator die zeitliche Reihenfolge des Auftretens von Ereignistypen fest. Zum 
Beispiel $A \rightarrow B$. Diese Regel akzeptiert die Ereignisfolge $c_1a_1a_2c_2b_1$. 
Des Weiteren existieren die boolesche Operatoren $\land , \lor$, die keine Reihenfolge 
des Auftretens beschreiben, da das Kommutativgesetz gilt: $A \circ B = B \circ A, \circ 
\in {\lor,\land}$. Ebenso existiert die Negation: $\neg A$. Die Kombination dieser 
Operatoren ermöglicht es komplexe Muster in Ereignisfolgen zu erkennen.\\
Eine weitere Algebra, welche von Anfragesprachen implementiert wird, ist die Algebra über 
\textbf{\textit{Kontextbedingungen}}. Mithilfe dieser Algebra ist es möglich direkt 
auf Attribute der Ereignisinstanzen über den $.$-Operator zugreifen zu können. Damit 
besteht die Möglichkeit die Attribute in Relation zu setzen Rechenvorschriften zu 
definieren. Zur Verfügung stehen dabei die numerischen Operatoren und 
Vergleichsoperatoren, aber auch Operatoren für Zeichenketten sind denkbar, oder gesondert 
definierte Methoden. Um in dieser Algebra verschiedene Entitäten von Ereignistypen zu 
betrachten, ist ein Operator zur Namenssubstitution vorhanden. Dieser Operator weist 
einem Ereignis eines Ereignistyps einen neuen Namen zu. Dieser binäre Operator könnte zum 
Beispiel $AS$ lauten. Das folgende Muster würde demnach die Werte des Attributes 
$humidity$ von einem Ereignis mit dem Ereignistyp $A$ mit einem Ereignis vom 
nachfolgenden Ereignistyp $B$ auf Gleichheit prüfen.
$$((A\, AS\, a)) \rightarrow (B\, AS\, b)) \land (a.humidity = b.humidity)$$
Aufgrund des endlosen Ereignisstromes, können die zuvor beschriebenen Muster nicht auf 
die ganze Menge der Ereignisse angewendet werden, da diese weder gespeichert werden 
können, oder nach kurzer Zeit schon nicht mehr von Interesse sind. Daher kommen 
sogenannte \textbf{\textit{sliding windows}} zum Einsatz. Diese erlauben es, nur einen 
gewisses Segment des Ereignisstromes für die Mustererkennung zu betrachten. Dabei werden 
laut \cite{bruns} und \cite{hedtstuck} zwei Fensterarten unterschieden. Das Zeitfenster 
berücksichtigt alle Ereignisse, die in einem zuvor festgelegtem Zeitraum eintreffen. 
Betrachtet man hingegen eine maximale Anzahl an Ereignissen innerhalb eines 
Ereignisstromes, dann spricht man von einem Längenfenster. Abbildung 
\ref{img:sliding-windows} aus \cite{drools-slide} verdeutlicht diesen Mechanismus. Dabei 
können die grauen Quader als beliebige Ereignisse oder als Ereignisse die einem 
Ereignismuster entsprechen verstanden werden.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/sliding-windows.png}
    \caption{sliding windows}
    \label{img:sliding-windows}
\end{figure}

Eine beispielhafte Ereignisregel mithilfe von sliding windows könnte folgendermaßen 
aussehen:
$$(A \rightarrow B)[win:time:5min] \rightarrow C$$
Dieses Muster ist erfolgreich, wenn innerhalb eines fünf minütigen Zeitfensters ein 
Ereignis des Ereignistyps B auf ein Ereignis des Ereignistyps A folgt und anschließend 
(zeitunabhängig) ein Ereignis vom Ereignistyp C eintritt.\\
Da es möglich ist mehrere Fensterinstanzen auf einen oder mehrere Ereignisströme parallel 
anzuwenden, kann mithilfe eines \textbf{Verschiebefaktors}\label{kap:verschiebefaktor}, 
wie er in \cite{hedtstuck} beschrieben 
ist, die Schnittmenge zweier aufeinanderfolgender Fenster angegeben werden. Dabei 
unterscheidet \cite{hedtstuck} nochmals in die \textit{Rolling Windows}, bei denen der 
Verschiebefaktor kleiner als die Länge des Fensters ist und zwei aufeinanderfolgende 
Fenster somit eine Schnittmenge besitzen und \textit{Tumbling Windows}, deren 
Verschiebefaktor größer oder gleich der Fensterlänge ist. Aufeinanderfolgende 
\textit{Tumbling Windows} sind zueinander Disjunkt und ist der Verschiebefaktor größer 
als die Fensterlänge, befinden sich zwischen ihnen nicht betrachtete Ereignisse. 
Abbildung \ref{img:factors} aus \cite{hedtstuck} zeigt den Einfluss des 
Verschiebefaktors auf aufeinanderfolgender Fensterinstanzen.

\begin{figure}[H]
    \centering
    \includegraphics[width=\linewidth]{img/factor-hedstuck}
    \caption{Verschiebefaktor}
    \label{img:factors}
\end{figure}

\subsubsection{Definition von Aktionen}
\vspace{0.1cm}
Wird ein Ereignismuster erkannt und ist damit die Prämisse einer Ereignisregel erfüllt, 
muss eine Aktion ausgeführt werden. Eine Aktion kann die Erstellung neuer Ereignisse 
sein, oder das Ausführen von Diensten, beziehungsweise Versenden von Meldungen.\\
Werden neue Ereignisse Erzeugt, so ist von der Ereignistransformation die Rede. In 
\cite{bruns} wird zwischen zwei Transformationen unterschieden. Den Transformationen, die 
keine Informationen zu einer transformierten Ereignisfolge hinzufügen und diejenigen, die 
dies tun. So kann im einfachsten Fall ein Ereignis eines gewissen Ereignistyps zu einem 
anderen Ereignistyp zugeordnet werden. Aktionen in Anfragesprachen erlauben auch die 
Filterung von Ereignissen. Mit einer gefilterten Menge an relevanten Ereignissen kann 
eine Leistungssteigerung der Musterkennung erfolgen. Zudem lässt sich eine Menge an 
Ereignissen zu einem neuen Ereignis zusammenfassen.\\
Darüber hinaus kann auch der Informationsgehalt von Ereignissen verändert werden, indem 
man Daten hinzufügt oder entfernt, zum Beispiel im Zuge einer Normalisierung eines 
Datenformats. Das generieren von komplexen Ereignissen erfolgt über Korrelation mehrerer 
einfacher Ereignisse, aus denen sich domänenspezifisches Wissen ableiten lässt. Als 
Beispiel soll die Erkennung einer \textit{BruteForce}-Attacke dienen:
\begin{align*}
&CONDITION:\\
&\quad (FailedLoginAttempt\, AS\, f)[win:time:5min]\\
&\quad \land\quad f.SourceIP\, =\, ''::1'' \\
&\quad \land\quad f.sum(count)\, AS\, FailCounter\\
&\quad \land\quad FaileCounter >= 10\\
&ACTION:\\
&\quad create \quad BruteForceAttack(SourceIP = f.SourceIP,\\
&\quad \quad Time=timestamp())
\end{align*}

%
% ESPER
%
\subsection{Esper}
\vspace{0.1cm}

Esper ist eine \textit{Complex Event Processing Engine} und stellt eine Laufzeitumgebung 
und einen Compiler für die eigene Ereignisanfragesprache \textit{Event Processing 
Language (EPL)} zur Verfügung. Der Compiler Übersetzt \textit{EPL} in Bytecode für die 
\textit{Java Virtual Machine}. Esper ist ebenfalls in der Programmiersprache Java 
implementiert, mit Nesper existiert allerdings auch eine Implementierung in C\#. Da nicht 
auf einer endlichen Menge an Daten nach Mustern gesucht wird, lässt sich Esper eher als 
eine invertierte Datenbank verstehen. Als erstes teilt man dem Compiler mithilfe einer 
zuvor erstellten Konfiguration das Event-Schema mit, um ihm anschließend ein 
EPL-Statement zur Übersetzung zur Verfügung zu stellen (Abbildung \ref{java:01}). 

\begin{figure}[h]    
\begin{minted}[mathescape,bgcolor=shadecolor]{java}
EPCompiler c = EPCompilerProvider.getCompiler();
Configuration conf = new Configuration();
conf.getCommon().addEventType(PersonEvent.class);

CompilerArguments cargs = 
    new CompilerArguments(conf);
EPCompiled epCompiled;
epCompiled = c.compile("@name('statement')
    select name, age from PersonEvent
    where (age/5) > 5", cargs);
\end{minted}
\caption{Initialisierung des Compilers}
\label{java:01}
\end{figure}

Die Laufzeitumgebung verwendet dann das zuvor übersetzte Statement und wendet es auf 
einen Ereignisstrom an. Ereignisse sind in diesem Fall Objektinstanzen der Klasse 
PersonEvent. Ein \textit{Listener} kann die zutreffenden Resultate verarbeiten. In 
diesem Beispiel (Abbildung \ref{java:02}) aus \cite{esper-reference} werden die 
Ereignisparameter \textit{name} und \textit{age} ausgegeben.

\begin{figure}[h]    
\begin{minted}[mathescape,bgcolor=shadecolor]{java}
EPRuntime rt =
    EPRuntimeProvider.getDefaultRuntime(conf);
    
EPDeployment deployment;
deployment =
    rt.getDeploymentService().deploy(epCompiled);
    
EPStatement statement =         
    rt.getDeploymentService().getStatement(
        deployment.getDeploymentId(),"statement");
        
statement.addListener(new UpdateListener() {
public void update(EventBean[] newData,
    EventBean[] oldData, EPStatement statement,
    EPRuntime rt) {
    
    String name = (String) newData[0].get("name");
    int age = (int) newData[0].get("age");
    System.out.println(
        String.format("Name: %s,
            Age: %d",name, age));
}});
\end{minted}
    \caption{Initialisierung der Laufzeitumgebung}
    \label{java:02}
\end{figure}

Um an die Esper-Laufzeitumgebung Ereignisse zu senden, müssen neue Ereignisinstanzen 
Erzeugt werden und an die Laufzeitumgebung gesendet werden, wie in Abbildung \ref{java:03}
gezeigt

\begin{figure}[h]    
\begin{minted}[mathescape,bgcolor=shadecolor]{java}
for (int i = 0; i <= 100; i++) {
runtime.getEventService().sendEventBean(
    new PersonEvent("Peter", i), "PersonEvent");
}
\end{minted}
\caption{Senden von Ereignissen}
\label{java:03}
\end{figure}

\subsubsection{Die Anfragesprache EPL}
\vspace{0.1cm}
Die \textit{Event Processing Language} von Esper ist stark an \textit{SQL} angelehnt, 
bietet aber Erweiterungen für die Verarbeitung von Ereignissen in einem endlosen 
Ereignisstrom. Ähnlich wie bei SQL ist ein statement folgendermaßen aufgebaut:

\texttt{select DATENAUSWAHL from EREIGNISSTROM where FILTER}

Um Anfragen an einen Ereignisstrom zu validieren, bietet der Entwickler von Esper, 
EsperTech Inc., das Werkezug EPL-Online (\cite{epl-online}) an. Basierend auf den 
Voreinstellungen in \cite{epl-online} werden die nachfolgenden Beispielanfragen an den 
Ereignisstrom \texttt{StockTick} gerichtet. Der Zuegörige Ereignistyp wurde zuvor durch 
das folgende EPL-statement definiert. Die neuen Erzeugten Ereignisse werden durch einen 
\textit{Listener} entgegengenommen und sind als Ausgabe verfügbar.

\texttt{create schema StockTick(symbol string, price double);}

Die verwendeten Datentypen sind stark an die primitiven Datentypen der Programmiersprache 
Java angelehnt (\texttt{boolean, integer, long, double, float, byte}). Es existiert aber 
auch der Datentyp \texttt{string}, für die Speicherung von unbegrenzt großen 
Zeichenketten.

Für die Beispiele wird ein Ereignisstrom verwendet, der diesem Schema 
entspricht.

\begin{verbatim}
StockTick={symbol='YHOO', price=65}
StockTick={symbol='IBM', price=141}
t=t.plus(2 seconds)
StockTick={symbol='IBM', price=142}
StockTick={symbol='YHOO', price=62}
t=t.plus(2 seconds)
StockTick={symbol='IBM', price=146}
StockTick={symbol='YHOO', price=63}
t=t.plus(2 seconds)
StockTick={symbol='YHOO', price=64}
StockTick={symbol='IBM', price=147}
t=t.plus(6 seconds)
\end{verbatim}

Die Variable \texttt{t} symbolisiert dabei die vergangene Zeit zwischen dem Eintreten von 
Ereignissen. Dabei sind \texttt{t = t+2000} und \texttt{t=t.plus(2 seconds)} äquivalente 
Ausdrücke. 

Das einfachste Muster, dass mithilfe von EPL beschrieben werden kann, ist die Filterung 
aller Ereignisse.

\texttt{select * from StockTick();}

Einfache Bedingungen lassen sich mit \texttt{where} realisieren. 

\texttt{select * from StockTick() where price > 100;}

Eine Aggregation über alle Events kann mittels vordefinierter Funktionen erfolgen. EPL 
stehen neben den einfachen Funktionen wie \texttt{avg(), count(), sum()} auch 
statistische Methoden zur Verfügung (siehe Tabelle 10.5 in \cite{esper-reference}).

Die nächste Anfrage zählt die Anzahl aller Ereignisse und bildet den Durchschnitt über 
alle Kurspreise der IBM-Aktie.

\texttt{select  count(*),avg(price) from StockTick()\\where symbol='IBM'}

Die zuvor gezeigten Beispiele eignen sich nicht zur Anfrage auf einen endlosen 
Ereignisstrom, da alle Ereignisse angefragt werden. Ein endgültiges Ergebnis würde ein 
Ende des Ereignisstromes voraussetzen, daher finden im Rahmen von \textit{CEP} die in 
Kapitel \ref{kap:ereignisregeln} beschriebenen Fenster Verwendung. Die anschließende 
EPL-Anfrage setzt ein auf Zeit basierendes \textit{sliding window} ein und berechnet den 
Durchschnittspreis der IBM-Aktie der letzten 6 Sekunden:

\texttt{select  avg(price) from StockTick().win:time(6 sec)\\where symbol='IBM'}

Da es sich hierbei um ein normales Fenster ohne expliziten Verschiebefaktor handelt 
(siehe auch Abschnitt \ref{kap:verschiebefaktor}), werden insgesamt 8 Ergebnisse 
ausgegeben. Trifft ein Muster auf ein Ereignis zu, so bekommt dieses Ereignis eine 
Gültigkeitsdauer zugeordnet, es ist damit in das Fenster aufgenommen wurden. Läuft die 
Gültigkeitsdauer ab, so wird das Ereignis aus dem Fenster entfernt. Folgende Übersicht 
soll die Funktion der einfachen Fenster in Esper verdeutlichen. Dabei wird sich auf den 
oben eingeführten Ereignisstrom und die letzte Anfrage bezogen.

\begin{table}[ht]
    \caption{Fenster ohne Verschiebefaktor}
    \label{table:ereignis}\vspace{0.2cm}
    \centering{
        \renewcommand{\arraystretch}{1.3}
        \begin{tabular}{|l|c|c|c|l|}
            \hline
            \cellcolor{shadecolor}\#   &\cellcolor{shadecolor} 2 Sek.    
            &\cellcolor{shadecolor} 4 Sek.    &\cellcolor{shadecolor} 6 Sek. & 
            \cellcolor{shadecolor}avg \\  
            \hline
            1   &       &        &(141)         &   141\\
            2   &       &(141)   &(142)         &   141.5\\
            3   &(141)  &(142)   &(146)         &   143\\
            4   &(142)  &(146)   &              &   144\\
            5   &(142)  &(146)   &(147)         &   145\\
            6   &(146)  &(147)   &              &   146.5\\
            7   &(147)  &        &              &   147\\
            8   &       &        &              &   NULL\\ 
        \hline   
        \end{tabular} 
    }
\end{table}

Da dieses Vorgehen wenig Intuitiv erscheint existieren in EPL auch Längen- und 
Zeitfenster mit einem Verschiebefaktor. Die sogenannten \texttt{batch}-Fenster sind 
\textit{Tumbling Windows}, deren Verschiebefaktor der Länge der Fenster entspricht. Die 
gleiche Anfrage mithilfe eines \texttt{batch}-Fensters verhält sich folgendermaßen.

\texttt{select  avg(price) from StockTick().win:time\_batch(6 sec)where symbol='IBM'}
\newpage
\begin{table}[ht]
    \caption{\texttt{batch}-Fenster}
    \label{table:ereignis}\vspace{0.2cm}
    \centering{
        \renewcommand{\arraystretch}{1.3}
        \begin{tabular}{|l|c|c|c|l|}
            \hline
            \cellcolor{shadecolor}\#   &\cellcolor{shadecolor} 2 Sek.    
            &\cellcolor{shadecolor} 4 Sek.    &\cellcolor{shadecolor} 6 Sek. & 
            \cellcolor{shadecolor}avg \\  
            \hline
            1   &(141)       &(142) &(146)  &   143\\
            2   &(147)       &      &       &   147\\
            \hline   
        \end{tabular} 
    }
\end{table}



%
% Problembeispiel
%

\subsection{Problembeispiel mit Esper}
\vspace{0.1cm}
\subsubsection{Problembeschreibung}
\vspace{0.1cm}
\subsubsection{Implementierung mit Esper}
\vspace{0.1cm}
\subsubsection{Ergebnis}
\vspace{0.1cm}


%
% Schlussfolgerung
%

\section{Schlussfolgerung}
\vspace{0.1cm}

%\section{Danksagung}
%Vielen Dank an die Entwickler von Esper und die gute Dokumentation der Software.\\

\appendix
\vspace{0.1cm}
%
% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{bib/bibo}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file
%  and remember to run:
% latex bibtex latex latex
% to resolve all references
%
% ACM needs 'a single self-contained file'!
%
%APPENDICES are optional
%\balancecolumns

%Appendix A


\end{document}
